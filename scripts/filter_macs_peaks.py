#!/usr/bin/env python

import re
import os
import sys
from collections import defaultdict
from optparse import OptionParser, SUPPRESS_HELP
from random import shuffle

from chipsequtil import MACSFile, MACSOutput, get_file_parts
from chipsequtil.util import MultiLineHelpFormatter as MF
from terminalcontroller import warn

usage = "%prog [options] <MACS peak file>"
description = """\
Filter MACS peaks by supplied criteria.  Available filter features are:

length
tags
pvalue
fold_enrichment
fdr

Filters are provided as expressions using the [-f |--filter] option, e.g. the command

%prog -f "tags>100" --filter="pvalue<=1e-9" --filter="100<length<=200" <MACS peak file>

finds only peaks with more than 100 tags, a pvalue of less than 1e9, and a length \
between 100, exclusive, and 200, inclusive.  Any number of filters may be provided, \
and only peaks that match *all* filters pass.  User is warned if filters result in \
zero results.  Only inequality operators are valid.  Invoking with no filter arguments \
returns all peaks.  To sort, use the --sort-by option, e.g.

%prog -f "pvalue<=1e-9" --sort-by=pvalue <MACS peak file>

sorts peaks with a pvalue smaller than 1e-9 with the smallest pvalue peaks.  All fields \
are sorted ascending by default.  Output is prepended with comments describing what \
the file contains, i.e. which filters are applied, how many records there are, etc.

Note: MACS -10*log10(pvalue) values are converted to normal pvalues
"""

parser = OptionParser(usage=usage,description=description,formatter=MF())
parser.add_option('-f','--filter',dest='filters',default=[],action='append',help='add filter expression')
parser.add_option('--sort-by',dest='sort_by',default='',help='comma delimited list of features to sort by, filtered peaks are not sorted by default, if provided peaks are sorted ascending by default')
parser.add_option('--sort-dir',dest='sort_dir',type='choice',choices=['ASCEND','DESCEND'],default='ASCEND',help='direction to sort [default: %default]')
parser.add_option('--top',dest='top',type='int',default=None,help='accepts an integer, output at most this many peaks [default: all]')
parser.add_option('--output',dest='output',default=None,help='filename to output filtered peaks to [default: stdout]')
parser.add_option('--encode-filters',dest='encode_filters',action='store_true',help='write out records to a file <MACS peaks file>_<filters>.xls (incompatible with --output option)')
parser.add_option('--summary',dest='summary',action='store_true',help='only print out summary information for the filter')
parser.add_option('--no-header',dest='no_header',action='store_true',help='do not print out header or metadata info')
parser.add_option('--shuffle',dest='shuffle',action='store_true',help='shuffle order of filtered records, useful for selecting random peaks')

parser.add_option('--print-encoded-fn',dest='print_encoded_fn',action='store_true',help="print out the filename that would be created by --encode-filters")

# make condition function objects using closures
_lt = lambda x,y : x < y
_lte = lambda x,y : x <= y
_gt = lambda x,y : x > y
_gte = lambda x,y : x >= y
_cond_map = {'<':_lt,'<=':_lte,'>':_gt,'>=':_gte,None:None}

def make_condition(low_val=None,low_test=_gte,high_val=None,high_test=_lte) :
    if low_val and not high_val :
        return lambda x: low_test(low_val,x)
    elif not low_val and high_val :
        return lambda x: high_test(x,high_val)
    elif low_val and high_val :
        return lambda x: low_test(low_val,x) and high_test(x,high_val)
    else :
        return lambda x: True # identity with no constraints

# regex and function for parsing filter strings
numeric_regex_str = r'\d+(?:\.\d*)?(?:(?:e|E)-?\d+)?' # matches numeric-looking patterns, e.g. 1, 1.234, 1e4, 1.234E-5, etc.
separator_regex_str = r'(?:>|>=|<|<=)'
ids_regex_str = r'(?:tags|pvalue|fold_enrichment|fdr|length)'
filter_regex = re.compile('^(%(num)s)?(%(sep)s)?(%(id)s)(%(sep)s)?(%(num)s)?$'%{'num':numeric_regex_str,'sep':separator_regex_str,'id':ids_regex_str})

class FilterException(Exception) : pass

def parse_filter(filter_str) :
    match = filter_regex.search(filter_str.strip())
    if match is None :
        raise FilterException('Filter %s is formatted incorrectly'%filter_str)
    low_val, low_test, field, high_test, high_val = match.groups()
    low_val = float(low_val) if low_val else low_val
    high_val = float(high_val) if high_val else high_val
    return field, make_condition(low_val,_cond_map[low_test],high_val,_cond_map[high_test])

_sort_keys = {'length': lambda x: int(x[3]),
              'tags': lambda x: int(x[5]),
              'pvalue': lambda x: 10**(float(x[6])/-10),
              'fold_enrichment': lambda x: float(x[7]),
              'fdr': lambda x: float(x[8]),
             }


summary_str = """\
# This output was generated by filter_macs_peaks.py, filtered from %(macs_fn)s
# Number of peaks: %(num_recs)d
# Filters: %(filters)s
# Sorted by: %(sort_by)s
# Shuffled: %(shuffled)s
"""
if __name__ == '__main__' :

    opts, args = parser.parse_args(sys.argv[1:])

    if len(args) < 1 :
        parser.error('Must provide one MACS peaks file')

    if opts.output is not None and opts.encode_filters :
        parser.error('--output and --encode-filters options are mutually exclusive')

    # set where to write output
    if opts.encode_filters :
        # construct filename additions
        fn_str = ''
        opts.filters.sort()
        for filt in opts.filters :
            filter_str = filt.replace(' ','')
            filter_str = filter_str.replace('>=','_GTE_')
            filter_str = filter_str.replace('<=','_LTE_')
            filter_str = filter_str.replace('>','_GT_')
            filter_str = filter_str.replace('<','_LT_')
            fn_str += '_%s'%filter_str

        if opts.top is not None :
            fn_str += '_top%d'%opts.top

        if len(opts.sort_by) != 0 :
            fn_str += '_sortby_%s'%opts.sort_by

        if opts.shuffle :
            fn_str += '_shuffled'

        macs_path,macs_fn,macs_basefn,macs_ext = get_file_parts(args[0])
        encoded_fn = os.path.join(macs_path,macs_basefn+fn_str+macs_ext)
        if opts.print_encoded_fn :
            sys.stdout.write(encoded_fn)
            sys.exit(0)
        else :
            out_f = open(encoded_fn,'w')
    elif opts.output :
        out_f = open(opts.output,'w')
    else :
        out_f = sys.stdout

    # parse the filters
    field_filters = defaultdict(list)
    for filter in opts.filters :
        field, filter_cond = parse_filter(filter)
        field_filters[field].append(filter_cond)

    # start processing MACS file
    peaks = MACSFile(args[0])

    # filter the records
    pass_recs = []
    for peak in peaks :
        # test each of the fields, if any one fails skip the record
        if not all([c(int(peak['length'])) for c in field_filters['length']]) or \
           not all([c(int(peak['tags'])) for c in field_filters['tags']]) or \
           not all([c(10**(float(peak['-10*log10(pvalue)'])/-10)) for c in field_filters['pvalue']]) or \
           not all([c(float(peak['fold_enrichment'])) for c in field_filters['fold_enrichment']]) or \
           not all([c(float(peak['FDR(%)'])) for c in field_filters['fdr']]) :
           continue
        else :
            pass_recs.append([peak[k] for k in MACSOutput.FIELD_NAMES])

    # sorting
    if opts.sort_by :
        pass_recs.sort(key=_sort_keys[opts.sort_by],reverse=opts.sort_dir != 'ASCEND')

    # top records
    num_recs = len(pass_recs) if not opts.top else min(len(pass_recs),opts.top)

    # construct the summary string
    filters_str = 'none' if len(opts.filters) == 0  else ', '.join(opts.filters)
    sort_str = 'original order' if not opts.sort_by else opts.sort_by+', '+opts.sort_dir
    shuffled_str = str(opts.shuffle)
    summary = summary_str%{'macs_fn':args[0],'num_recs':num_recs,
                           'filters':filters_str,
                           'sort_by':sort_str,
                           'shuffled':shuffled_str}

    if len(pass_recs) == 0 :
        warn('WARNING: no records remain after filtering\n')
        if not opts.no_header :
            out_f.write(summary)
            out_f.write('\t'.join(MACSOutput.FIELD_NAMES)+'\n')
        sys.exit(1)

    # print summary only
    if opts.summary :
        sys.stdout.write(summary)
        sys.exit(0)

    # write out the header cuz it's a nice thing to do
    if not opts.no_header :
        out_f.write(summary)
        out_f.write('\t'.join(MACSOutput.FIELD_NAMES)+'\n')

    # write out records
    if opts.shuffle :
        shuffle(pass_recs)
    out_recs = pass_recs[:num_recs]

    for rec in out_recs :
        out_f.write('\t'.join(map(str,rec))+'\n')

    # good programming practice
    out_f.close()
